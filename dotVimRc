" ================================================
"         .__           ___.
"  ___  __|__|  _____   \_ |__    ____  ___  ___
"  \  \/ /|  | /     \   | __ \  /  _ \ \  \/  /
"   \   / |  ||  Y Y  \  | \_\ \(  <_> ) >    <
"    \_/  |__||__|_|  /  |___  / \____/ /__/\_ \
"                   \/       \/               \/
" ================================================
"
"
" See `README.md` for features and shortcuts
" Additional features not mentioned in README:
"
" Spell Check:
" Command+shift+p to toggle spell check on comments (underlines in red).
"
" Mac ProTips:
"  To further improve the text rendering on Mac OSX:
"  1. From the shell: defaults write org.vim.MacVim MMCellWidthMultiplier 0.9
"  2. Opens all files from other apps in vert split
"
"      defaults write org.vim.MacVim MMVerticalSplit YES
"      defaults write org.vim.VimBox MMVerticalSplit YES
"
"  3. If when changing monitors, your fonts go from nice and thin to ugly and
"  bold: This should fix it:
"   Textmate disables font smoothing only for dark backgrounds, but MacVim
"   only has a global setting. If you use dark backgrounds consider disabling.
"   https://stackoverflow.com/questions/24598390/macvim-thicker-font-rendering-compared-to-textmate
"
"   defaults write org.vim.MacVim AppleFontSmoothing -int 0
"   defaults write org.vim.VimBox AppleFontSmoothing -int 0
"
"  4. Speed up full screen transition:
"
"      defaults write org.vim.MacVim MMFullScreenFadeTime 0.05
"      defaults write org.vim.VimBox MMFullScreenFadeTime 0.05
"
" Cygwin:
" Tested and should work. AutoHotkey exist that provide an identical experience
" to the Mac OSX experience.
"
" Bundle System:
" =================================================================
" Uses the VimPlug system. Add bundles to ~/.vim/bundlesVimRc with:
" Plug "githubUser/repo"
" Open a new window and then run `:PlugInstall`
" Close and then reopen the vim window.

" Performance Profiling:
" ========================
" http://stackoverflow.com/questions/12213597/how-to-see-which-plugins-are-making-vim-slow
"
" Find Slow Plugins During Actions:
" =================================
"
"   :profile start profile.log
"   :profile func *
"   :profile file *
"   " At this point do slow actions
"   :profile pause
"   :noautocmd qall!
"
" Profile Startup Time:
" ==================================================================
"   mvim --startuptime ~/.vim/timeCost.txt ~/.vim/timeCost.txt
"
" Debugging VimSript Errors:
" ==================================================================
" Ever have this happen to you?
"
"    Error <SNR>49_Destroy[10]...Line 3
"
" This is Vim's idea of a good error message (when one of your plugin throws
" an error). See that weird <SNR>49? That's the script number which is
" assigned to the VimScript file behind the scenes (invisibly to you) - Here's
" how you find out which script that is. Execute :scriptnames and find the
" corresponding number in that list.  So <SNR>49 means script number 49, and
" Destroy, UnsetIMap are the last two functions in the stack trace (so the
" problem is ultimately in UnsetIMap in my case).  And that "line 3"?  That's
" not the line number in the file like any reasonable error message would
" display that's the line number within the deepest function.

" Seeing Who Is Setting A Setting:
" =================================================================
" :verbose set settingName?

" Using In Terminal
" ================
" Using VimBox in your terminal is semi-supported. It should work, but it is
" not tested often. If you see something off, please report but a PR is
" the best way to move VimBox forward with terminal support.
"
" Note: If you use iTerm, and you want airline symbols to show up correctly
" you must change the font in *two* places in iTerm. The normal font, and the
" non-ascii font!
"
" Remote Editing:
"
" - Speed up performance at the network layer:
"   http://thomer.com/howtos/netrw_ssh.html
" - Help netrw-passwd
"
" - Also good suggestions here: https://stackoverflow.com/questions/28795721/how-to-save-in-vim-a-remote-file-asynchronously
"   - As always disable airline/lightline vcs integration.
" - https://github.com/eshion/vim-sync/
" - https://github.com/grantm/bcvi
" - https://github.com/seletskiy/vim-refugi

" if v:version < 799
  " echomsg "VimBox works best with Vim8 or newer. Please upgrade your Vim/MacVim"
" endif

" TODO: Integrate a mingw/cygwin shell via:
"  shell: 'C:\\Program Files\\Git\\git-cmd.exe --command=usr/bin/bash.exe -l -i'
"  let &shell = 'C:\\Program Files\\Git\\git-cmd.exe --command=usr/bin/bash.exe -l -i'

" This has to be before setting any settings like filetype/syntax on.
" But before doing this, we need to reconstruct the menus.
" set guioptions+=M


" These will be useful one day when detecting old VimBox installs. Most of
" vim-box can simply be plugins which are auto-updated using Plug, but the
" shell, loader, initialization vimrc, and application wrappers cannot be.
" These version numbers describe the version of all of that "host"
" infrastructure which is more difficult to update. The plugs updated via
" Plug, can check these vars.
let g:vimBox_host_version_major = 0
let g:vimBox_host_version_minor = 0
let g:vimBox_host_version_patch = 0

let s:useSettingsSystem = 1

let g:vimBoxIsLoading = 1
let g:vimBoxInfosDuringLoad = []
let g:vimBoxSuccessesDuringLoad = []
let g:vimBoxWarningsDuringLoad = []
let g:vimBoxErrorsDuringLoad = []

let skipGeneration = 0

" Find Location Of VimBox Installation:
" =====================================
" From: https://stackoverflow.com/questions/4976776/how-to-get-path-to-the-current-vimscript-being-executed
" Symlink Resolved Location Of VimBox Installation: (Won't Always Be .vim!):
" Note: Has to be run from top level scope, not inside function.
let g:vimBoxInitialVimRcPath = resolve(expand('<sfile>:p'))
let g:vimBoxInstallationRoot = fnamemodify(g:vimBoxInitialVimRcPath, ':h')


" Source The Utilities That Help Us Bootstrap The Startup:
" ========================================================
" For some reason these have to be manually sourced even if we only used their contents after plug#end
" Any functions used in the startup process, even if we've executed plug#end.
" We first need to manually source this one file which defines all the path
" utilities and the OS:
execute "source " . g:vimBoxInstallationRoot . "/dotVim/localBundle/vim-box/plugin/vimBoxUtils.vim"
let g:vimBoxStockPluginsDir = PathJoinDir(PathJoinDir(g:vimBoxInstallationRoot, 'dotVim'), 'localBundle')

" When overriding init files (-u/-U flags), the standard ones don't get
" sourced. They are very important on some systems/guis. Things fail without
" this and I don't know why. Probably some cpoptions settings?  We set
" `VIMBOX_OVERRIDING_INIT` to tell these loading scripts they need to source
" the defaults.
" NOTE: On second thought, there is no need to set a flag. This vimrc file
" will always be sourced only at init time.
" `vim --version` will tell you where these system vim files are, but on
" macos, neovim claims to load $VIM/sysinit.vim but it doesn't even exist
" when installed through brew. It doesn't seem to be necessary though.
"
" See `./developerDocs/LOCATIONS.md`
" if g:vimBoxVimType == 'regularvim' && ($VIMBOX_OVERRIDING_INIT)
if g:vimBoxVimType == 'regularvim'
  if g:vimBoxOs == 'windows'
    " Cygwin installed vim
    if g:vimBoxSupportsUnix
      if file_readable('/etc/vimrc')
        exec "source /etc/vimrc"
      endif
    else
      " GVim binary (command line or GUI)
      " Nothing actually important here. Commenting out.
      " exec "source " . $VIM . "/_vimrc"
    endif
  elseif g:vimBoxOs == 'osx'
    exec "source " . $VIM . "/vimrc"
  elseif g:vimBoxOs == 'linux'
    if file_readable($VIM . '/vim82/vimrc_example.vim')
      exec "source " . $VIM . "/vim82/vimrc_example.vim"
    else
      if file_readable($VIM . '/vimrc')
        exec "source " . $VIM . '/vimrc'"
      endif
    endif
  endif
  " Passing -u even turns off `defaults` loading.
  exec "source " . $VIMRUNTIME . "/defaults.vim"
elseif g:vimBoxVimType == 'neovim'
  " Neovim requires:
  " let g:python_host_prog = '/full/path/to/neovim2/bin/python'
  " let g:python3_host_prog = '/full/path/to/neovim3/bin/python'
  " Usually the user will need to use pip (bleh)
endif
if g:vimBoxOs == 'windows'
  set fileformats=unix,dos
  set encoding=utf-8
  " If starting gvim from mingw bash shell need to restart shell.
  " https://github.com/junegunn/vim-plug/issues/539
  " This might be not everything that is necessary. The latest vim-plug
  " includes more support for windows. Need to resync.
  if g:vimBoxGui=='gui'
    let &shell='cmd.exe'
  else
    " You really shouldn't be starting the *non* gui vim.exe from within git
    " bash shell apparently:
  endif
endif

" VimBox Comes With One Stock Plugin For VimBox: Called the vim-box plugin.
" For some reason these have to be manually sourced even if we only used their contents after plug#end
" Any functions used in the startup process, even if we've executed plug#end.
" I think these end up getting sourced twice. So we should add a check in
" these files to determine if they've already been loaded.
execute "source " . g:vimBoxInstallationRoot . "/dotVim/localBundle/vim-console/plugin/console.vim"
execute "source " . g:vimBoxInstallationRoot . "/dotVim/localBundle/vim-box/plugin/vimBoxMessage.vim"
execute "source " . g:vimBoxInstallationRoot . "/dotVim/localBundle/vim-box/plugin/vimBoxConfig.vim"
execute "source " . g:vimBoxInstallationRoot . "/dotVim/localBundle/vim-box/plugin/vimBox.vim"
execute "source " . g:vimBoxInstallationRoot . "/dotVim/localBundle/vim-box/plugin/vimBoxGeneratedRc.vim"

" When creating directory paths to be joined into a RTP, we do *not* want to
" include a trailing final `\` because it escapes the comma! So we
" intentionally use PathJoinFile even though it's a dir.
" https://github.com/google/vim-maktaba/issues/72
let &runtimepath=&runtimepath . ',' .  PathJoinFile(g:vimBoxStockPluginsDir, 'vim-console')
let &runtimepath=&runtimepath . ',' .  PathJoinFile(g:vimBoxStockPluginsDir, 'vim-plug')
let &runtimepath=&runtimepath . ',' .  PathJoinFile(g:vimBoxStockPluginsDir, 'json-ponyfill.vim')
let &runtimepath=&runtimepath . ',' .  PathJoinFile(g:vimBoxStockPluginsDir, 'color-tools')
let &runtimepath=&runtimepath . ',' .  PathJoinFile(g:vimBoxStockPluginsDir, 'vim-box')
" execute "source " . g:vimBoxInstallationRoot . "/dotVim/localBundle/json-ponyfill.vim/autoload/json_ponyfill.vim"

" We will follow the XDG Spec as NeoVim Does:
" https://github.com/neovim/neovim/issues/78
" https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html
" Cache:
"     ~/.cache/vim-box/
" Data: Undo/backup files.
"     ~/.local/share/vim-box/
" User Config:
"     ~/.config/vim-box/
"
" Because neovim and regular vim cannot mix every type of config file (for
" example, undo file format), we have separate directories for all your vim
" config/cache/data and all your neovim config/cache/data.  Instead of
" appending `vim-box` we will append `vim-box-neovim`.
" Let's also allow for creating clean plugin sandboxes to test blank configs.
" They will be created like `..../vim-box-sandboxname` or
" `..../vim-box-neovim-sandbox-name`.
" That directory name pattern will be called the "suffix".

if g:vimBoxVimType == 'neovim'
  let g:vimBoxSandboxSuffix = 'vim-box-neovim'
else
  let g:vimBoxSandboxSuffix = 'vim-box'
endif
if ($VIMBOX_SANDBOX_NAME != "")
  let g:vimBoxSandboxSuffix = g:vimBoxSandboxSuffix . '-' . $VIMBOX_SANDBOX_NAME
endif
let g:vimBoxSettingsDefault = PathJoinFile(PathJoinDir(g:vimBoxStockPluginsDir, g:vimBoxSandboxSuffix), 'settings.json')

" Location Of Home Directory:
let g:vimBoxHomeDir = $HOME . _VimBoxSlashFor( $HOME )

" Some XDG Defaults:
let g:vimBoxDefaultCacheDir = PathJoinDir(g:vimBoxHomeDir, '.cache')
let g:vimBoxDefaultDataDir = PathJoinDir(PathJoinDir(g:vimBoxHomeDir, '.local'), 'share')
let g:vimBoxDefaultConfigDir = PathJoinDir(g:vimBoxHomeDir, '.config')

" Where Cache Files Should Be Stored: (Default $HOME/.cache):
let g:vimBoxXdgCacheDir = exists('$XDG_CACHE_HOME') ? PathJoinDir($XDG_CACHE_HOME, g:vimBoxSandboxSuffix) : PathJoinDir(g:vimBoxDefaultCacheDir, g:vimBoxSandboxSuffix)
" Where User Specific Data Files Should Be Written: (undo/backup files) (Default $HOME/.local/share):
let g:vimBoxXdgDataDir = exists('$XDG_DATA_HOME') ? PathJoinDir($XDG_DATA_HOME, g:vimBoxSandboxSuffix) : PathJoinDir(g:vimBoxDefaultDataDir, g:vimBoxSandboxSuffix)
" Where User Specific Configuration Should Be Stored: (Default $HOME/.config)
let g:vimBoxXdgConfigDir = exists('$XDG_CONFIG_HOME') ? PathJoinDir($XDG_CONFIG_HOME, g:vimBoxSandboxSuffix) : PathJoinDir(g:vimBoxDefaultConfigDir, g:vimBoxSandboxSuffix)
if !isdirectory(g:vimBoxXdgCacheDir)
  call mkdir(g:vimBoxXdgCacheDir, "p")
endif
if !isdirectory(g:vimBoxXdgDataDir)
  call mkdir(g:vimBoxXdgDataDir, "p")
endif
if !isdirectory(g:vimBoxXdgConfigDir)
  call mkdir(g:vimBoxXdgConfigDir, "p")
endif

" TODO: This should be sourced from the location of current vim script so that
" you can use VimBox without having to install it over your old vim install.
let g:vimBoxUndoDir = PathJoinDir(g:vimBoxXdgDataDir, 'undo')
let g:vimBoxSessionDir = PathJoinDir(g:vimBoxXdgDataDir, 'vim_sessions')
" This isn't really that valuable, now that we have :Console
let g:vimBoxLogsDir = PathJoinDir(g:vimBoxXdgDataDir, 'logs')
let g:vimBoxPluginInstallDir = PathJoinFile(g:vimBoxXdgDataDir, 'bundle')
if !isdirectory(g:vimBoxUndoDir)
  call mkdir(g:vimBoxUndoDir, "p")
endif
if !isdirectory(g:vimBoxSessionDir)
  call mkdir(g:vimBoxSessionDir, "p")
endif
if !isdirectory(g:vimBoxLogsDir)
  call mkdir(g:vimBoxLogsDir, "p")
endif
if !isdirectory(g:vimBoxPluginInstallDir)
  call mkdir(g:vimBoxPluginInstallDir, "p")
endif
let g:vimBoxLogsCurrentSession = PathJoinFile(g:vimBoxLogsDir, strftime("%F"))
" The automatically generated vimrc file based on config. Useful for reproing
" and sharing.
let g:vimBoxGeneratedRc = PathJoinFile(g:vimBoxXdgCacheDir, ".generated.vimrc")

" In Vim-box, the user customizes vim by making a "user" plugin which is in
" the simplest form, just an settings.json file, but can include directories
" like:
" plugin/
" autoload/
" ftdetect/
let g:vimBoxUserPluginDir = PathJoinDir(g:vimBoxXdgConfigDir, 'user')
if !isdirectory(g:vimBoxUserPluginDir)
  call mkdir(g:vimBoxUserPluginDir, "p")
endif

let g:vimBoxUserSettings = PathJoinFile(g:vimBoxUserPluginDir, 'settings.json')
" Sourced after vimbox does all the deafult behavior.
" Maybe the user init file should actualy be the one to source.
let g:vimBoxUserInit = PathJoinFile(g:vimBoxUserPluginDir, 'init.vim')
" See .gvimrc
let g:vimBoxUserGVimInit = PathJoinFile(g:vimBoxUserPluginDir, 'ginit.vim')

let g:vimBoxExampleUserConfigDir=PathJoinDir(g:vimBoxInstallationRoot, 'exampleUserConfig')
call VimBoxPopulateDefaultConfigs(g:vimBoxExampleUserConfigDir, g:vimBoxUserPluginDir)

if has('gui_win32')
  set rtp+=~/.vim
endif

if has('vim_starting')
   if &compatible
     set nocompatible               " Be iMproved
   endif
endif

" There's a huge circular dependency.  User config defines disabled plugins
" and installed plugins.  We need those plugins to be loaded before knowing
" the full runtime path to grab all config from. But we only have the ability
" to load all config from the runtime path. So we first load all the config
" when the runtime path only consists of user plugin. Then generate the plugin
" loader code. Then source it (which puts them all in the runtime path). Then
" we regenerate the config, and call the configure hook in that.
" The User is none the wiser. It's a little slower though, so we should avoid
" doing any computation unless config files changed.'
" call VimBoxLog('INIT', "Initializing New VimBox Session via home directory vimrc")

if !skipGeneration
  call VimBoxInitConfigs()
  " The generated VimRc defines one __VimBoxGeneratedPlugCalls() which calls
  " Plug for all the configured plugins. We will
  call VimBoxGenerateVimRc()
endif
execute "source " . g:vimBoxGeneratedRc

silent! call plug#begin(g:vimBoxPluginInstallDir)
" Add the special "user plugin" TODO: Allow for a user-before plugin as well
if exists("*__VimBoxGeneratedConfigure_disabler_ForScope_")
  call __VimBoxGeneratedConfigure_disabler_ForScope_()
endif
call __VimBoxGeneratedPlugCalls()
call plug#end()


" The suggestions here seemed overly complex.
" http://unix.stackexchange.com/a/5313
" The final comment here worked: http://vim.wikia.com/wiki/Disable_beeping
set belloff=all

try
  set shortmess+=filmnrxoOtTc
catch /E539: Illegal character/
  " Some versions do not like c
  set shortmess+=filmnrxoOtT
endtry
try
  set switchbuf+=useopen,usetab,vsplit
catch /E474: Invalid argument/
  set switchbuf+=useopen,usetab
endtry
" Disable Vim's startup screen
set shortmess+=I

" MacVim Quick Start is pretty strange. It's as if it always opens the *next*
" MacVim window whenever you open the currently visible one.
" So this prompt applies to the *next* window you'll open typically - in that
" case.
" Notice the ! not
if !len(filter(values(g:plugs), '!isdirectory(v:val.dir)'))
  " Now reconfigure now that plugins are all in the runtimepath and we can
  " actually see their included settings.json files.
  if !skipGeneration
    call VimBoxInitConfigs()
    call VimBoxGenerateVimRc()
  endif
  execute "source " . g:vimBoxGeneratedRc
  call __VimBoxGeneratedConfigureForScope_()
  " Some vim reset plugin screws up listchars
  set listchars = "eol:$"
else
  " Don't show statusline when airline might not be loaded or configured.
  colorscheme taste
  if g:vimBoxGui=='gui'
    set background=dark
    set guioptions-=r
    set guioptions-=R
    set guioptions-=l
    set guioptions-=L
    " The backticks and echo make it work better in terminal env
    autocmd VimEnter *
      \  if len(filter(values(g:plugs), '!isdirectory(v:val.dir)')) && 1==confirm("Download and Install Plugins?", "&Yes\n&No", 1)
      \|   set laststatus=0
      \|   PlugInstall --sync | echomsg "Open a new window to enjoy the plugins!" | let xx=confirm("Open a New Window For Plugins to Take Effect.")
      \| endif
    " Source the settings just in case they respond with "No, don't update plugins"
    " Now reconfigure now that plugins are all in the runtimepath and we can
    " actually see their included settings.json files.
    if !skipGeneration
      call VimBoxInitConfigs()
      call VimBoxGenerateVimRc()
    endif
    execute "source " . g:vimBoxGeneratedRc
    call __VimBoxGeneratedConfigureForScope_()
    " Some vim reset plugin screws up listchars
    set listchars = "eol:$"
  else
    set laststatus=0
    echomsg "Attempting to install plugins. Be patient. Vim is working in the background. It will start eventually."
    PlugInstall --sync
    " Now reconfigure now that plugins are all in the runtimepath and we can
    " actually see their included settings.json files.
    if !skipGeneration
      call VimBoxInitConfigs()
      call VimBoxGenerateVimRc()
    endif
    execute "source " . g:vimBoxGeneratedRc
    call __VimBoxGeneratedConfigureForScope_()
    " Some vim reset plugin screws up listchars
    set listchars = "eol:$"
  endif
endif

if file_readable(g:vimBoxUserInit)
  execute "source " . g:vimBoxUserInit
endif
let g:vimBoxIsLoading = 0


" Silence python3 deprecation warnings. There are some deprecation warnings in
" Ultisnips with the python3 API. Just clear out any of them once for all
" plugins that might use deprecated python APIs.
if has('python3')
  silent! python3 1
endif
